#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author:gentelyang  time:2019-05-31
#迭代器协议：必须提供next方法，执行该方法要么返回迭代中的下一项要么引起一个异常，以终止迭代。
#可迭代器对象：实现迭代器协议的对象（如何实现：对象内部定义一个__iter__()方法）
#协议是一个约定,可迭代对象实现了迭代器协议，python的内部工具使用迭代器协议访问对象

l = [1,2,3]
for i in l:
    print i
#上面的for循环可以使用一行代码代替
#下面的是列表解析方法，比较费内存
l2 = [i for i in range(1,3)]
# l3 = ["鸡蛋%s" %i for i in range(10)]#l3比l2多了一个字符串的拼接
l4 = [ '鸡蛋%s' %i for i in range(1,3)]
l5 = ['鸡蛋%s' %i for i in range(1,10) if i > 5]#比l3多了一个if判断，大于5的满足条件
#l5 只能加if，不能再加else了，最多只能到3元表达式，不能四元


index = 0
while index < len(l):
    index += 1
    print index
#for循环的本质就是使用迭代器协议，有next方法。for训练可遍历list\truple\dict\set等；
#但是list却没有next方法；for循环时遵循迭代器协议的。

#循环主要三种方法：1.下标索引；2：for循环； 3：while循环
#字符串、列表和元组为序列类型，可以根据下标索引进行循环，但是字典、集合和文件对象非序列不可以用下标索引，只能for或者while循环
#而for循环是基于迭代器协议提供了一个统一的可以遍历所有对象的方法，在利用for循环遍历之前会先调用一个__iter__()方法和next方法将其转为一个迭代器


#生成器
#生成器是一种数据类型，这种数据类型自动实现了迭代器协议，其它的数据类型需要调用自己内置的__iter__方法，所以生成器是可迭代对象
#1:生成器函数：常规函数定义，但是，使用yield语句而不是return语句返回结果，yield语句一次返回一个结果,在每个结果中间挂起函数的状态，一遍下次从它离开的地方继续执行
#只要有yiedl就是生成器；生成器就是迭代器，一定有next方法；__next__()
#2：生成器表达式：类似于列表推导，但是生成器返回


#列表解析可以求和等简单运算很方便
l6 = sum(i for i in range(3))#基于迭代器协议进行遍历求和
print l6

l7 = sum([i for i in range(3)])
print l7